//
//  PathToGCodeConverter.swift
//  LaserGRBL
//
//  Phase 4: SVG Vector Import
//  Created on October 19, 2025
//

import Foundation
import AppKit
import Combine

/// Converts SVG paths to G-code
class PathToGCodeConverter: ObservableObject {
    
    @Published var progress: Double = 0
    @Published var isConverting = false
    @Published var currentOperation: String = ""
    
    // MARK: - Conversion
    
    /// Convert an SVG document to G-code
    func convert(
        document: SVGDocument,
        settings: VectorSettings
    ) async throws -> String {
        await MainActor.run {
            isConverting = true
            progress = 0
            currentOperation = "Preparing paths..."
        }
        
        defer {
            Task { @MainActor in
                isConverting = false
                currentOperation = ""
            }
        }
        
        // Get visible paths only
        let paths = document.visiblePaths
        
        guard !paths.isEmpty else {
            throw ConversionError.noPaths
        }
        
        // Optimize path order if requested
        updateProgress(0.1, operation: "Optimizing path order...")
        let optimizedPaths = settings.optimizeOrder ?
            optimizePaths(paths, settings: settings) : paths
        
        // Generate G-code header
        var gcode = generateHeader(document: document, settings: settings)
        
        // Convert each path
        let totalPaths = optimizedPaths.count
        for (index, path) in optimizedPaths.enumerated() {
            updateProgress(
                0.1 + (0.8 * Double(index) / Double(totalPaths)),
                operation: "Converting path \(index + 1) of \(totalPaths)..."
            )
            
            gcode += try convertPath(path, settings: settings)
        }
        
        // Generate footer
        updateProgress(0.9, operation: "Finalizing...")
        gcode += generateFooter(settings: settings)
        
        updateProgress(1.0, operation: "Complete")
        
        return gcode
    }
    
    // MARK: - Header & Footer
    
    private func generateHeader(document: SVGDocument, settings: VectorSettings) -> String {
        var header = ""
        
        // Comment block
        header += "; Generated by LaserGRBL for macOS\n"
        header += "; \(Date().formatted())\n"
        
        if let title = document.metadata.title {
            header += "; Source: \(title)\n"
        }
        
        let bounds = document.boundingBox
        header += "; Dimensions: \(String(format: "%.2f", bounds.width)) x \(String(format: "%.2f", bounds.height)) mm\n"
        header += "; Paths: \(document.visiblePathCount)\n"
        header += ";\n"
        
        // G-code setup
        header += "G21 ; Set units to millimeters\n"
        header += "G90 ; Absolute positioning\n"
        header += "M5 ; Laser off\n"
        header += "G0 F\(settings.feedRate) ; Set feed rate\n"
        
        if settings.enableZAxis {
            header += "G0 Z\(String(format: "%.2f", settings.zSafeHeight)) ; Move to safe height\n"
        }
        
        header += "\n"
        
        return header
    }
    
    private func generateFooter(settings: VectorSettings) -> String {
        var footer = "\n"
        footer += "; End of program\n"
        footer += "M5 ; Laser off\n"
        
        if settings.enableZAxis {
            footer += "G0 Z\(String(format: "%.2f", settings.zSafeHeight)) ; Return to safe height\n"
        }
        
        footer += "G0 X0 Y0 ; Return to origin\n"
        footer += "M2 ; Program end\n"
        
        return footer
    }
    
    // MARK: - Path Conversion
    
    private func convertPath(_ path: SVGPath, settings: VectorSettings) throws -> String {
        var gcode = ""
        
        // Extract path elements
        let elements = path.getElements()
        guard !elements.isEmpty else { return gcode }
        
        var currentPoint: CGPoint?
        var pathStartPoint: CGPoint?
        
        for pass in 1...settings.passes {
            if settings.passes > 1 {
                gcode += "; Pass \(pass) of \(settings.passes)\n"
            }
            
            for element in elements {
                switch element {
                case .move(let to):
                    // Rapid move with laser off
                    if currentPoint != nil {
                        gcode += "M5 ; Laser off\n"
                    }
                    
                    gcode += formatRapidMove(to: to, settings: settings)
                    currentPoint = to
                    pathStartPoint = to
                    
                case .line(let to):
                    // Linear move with laser on
                    if currentPoint == nil {
                        currentPoint = CGPoint.zero
                    }
                    
                    gcode += "M3 ; Laser on\n"  // Turn laser on for cutting
                    gcode += formatCut(from: currentPoint!, to: to, settings: settings)
                    gcode += "M5 ; Laser off\n"  // Turn laser off after cut
                    currentPoint = to
                    
                case .quadCurve(let to, let control):
                    // Quadratic Bézier curve - subdivide into lines
                    guard let current = currentPoint else { continue }
                    
                    let curve = BezierTools.QuadraticBezier(
                        p0: current,
                        p1: control,
                        p2: to
                    )
                    
                    let points = BezierTools.subdivideQuadratic(
                        curve,
                        tolerance: settings.tolerance
                    )
                    
                    if points.count > 1 {
                        gcode += "M3 ; Laser on\n"  // Turn laser on for curve cutting
                        for point in points.dropFirst() {
                            gcode += formatCut(from: currentPoint!, to: point, settings: settings)
                            currentPoint = point
                        }
                        gcode += "M5 ; Laser off\n"  // Turn laser off after curve
                    }
                    
                case .cubicCurve(let to, let control1, let control2):
                    // Cubic Bézier curve - subdivide or use arcs
                    guard let current = currentPoint else { continue }
                    
                    let curve = BezierTools.CubicBezier(
                        p0: current,
                        p1: control1,
                        p2: control2,
                        p3: to
                    )
                    
                    if settings.useArcCommands {
                        // Try to fit an arc - use more lenient tolerance for fitting
                        // The arc tolerance controls how closely the arc must match the curve
                        let fittingTolerance = max(settings.arcTolerance, 0.1) // More lenient
                        let points = BezierTools.subdivideCubic(curve, tolerance: settings.tolerance)
                        
                        if let arc = BezierTools.fitArc(to: points, tolerance: fittingTolerance) {
                            gcode += "; Arc command (G\(arc.clockwise ? "2" : "3"))\n"
                            gcode += "M3 ; Laser on\n"  // Turn laser on for arc cutting
                            gcode += formatArc(arc, settings: settings)
                            gcode += "M5 ; Laser off\n"  // Turn laser off after arc
                            currentPoint = to
                            continue
                        }
                    }
                    
                    // Fall back to subdivision
                    let points = BezierTools.subdivideCubic(curve, tolerance: settings.tolerance)
                    
                    if points.count > 1 {
                        gcode += "M3 ; Laser on\n"  // Turn laser on for curve cutting
                        for point in points.dropFirst() {
                            gcode += formatCut(from: currentPoint!, to: point, settings: settings)
                            currentPoint = point
                        }
                        gcode += "M5 ; Laser off\n"  // Turn laser off after curve
                    }
                    
                case .close:
                    // Close the path
                    if let start = pathStartPoint, let current = currentPoint {
                        if distance(current, start) > 0.001 {
                            gcode += "M3 ; Laser on\n"  // Turn laser on for closing
                            gcode += formatCut(from: current, to: start, settings: settings)
                            gcode += "M5 ; Laser off\n"  // Turn laser off after closing
                            currentPoint = start
                        }
                    }
                }
            }
            
            // End of pass
            gcode += "M5 ; Laser off\n"
            
            // Z-axis depth increment for multiple passes
            if settings.enableZAxis && pass < settings.passes {
                let depth = -settings.passDepth * Double(pass)
                gcode += "G0 Z\(String(format: "%.3f", depth))\n"
            }
        }
        
        gcode += "\n"
        return gcode
    }
    
    // MARK: - G-code Formatting
    
    private func formatRapidMove(to point: CGPoint, settings: VectorSettings) -> String {
        var gcode = "G0"
        gcode += " X\(String(format: "%.3f", point.x))"
        gcode += " Y\(String(format: "%.3f", point.y))"
        
        if settings.enableZAxis {
            gcode += " Z\(String(format: "%.3f", settings.zCutHeight))"
        }
        
        return gcode + "\n"
    }
    
    private func formatCut(from: CGPoint, to: CGPoint, settings: VectorSettings) -> String {
        var gcode = "G1"
        gcode += " X\(String(format: "%.3f", to.x))"
        gcode += " Y\(String(format: "%.3f", to.y))"
        gcode += " S\(settings.laserPower)"
        
        return gcode + "\n"
    }
    
    private func formatArc(_ arc: BezierTools.Arc, settings: VectorSettings) -> String {
        let command = arc.clockwise ? "G2" : "G3"
        
        // Calculate end point
        let endX = arc.center.x + arc.radius * cos(arc.endAngle)
        let endY = arc.center.y + arc.radius * sin(arc.endAngle)
        
        // Calculate I and J (relative to start point)
        let startX = arc.center.x + arc.radius * cos(arc.startAngle)
        let startY = arc.center.y + arc.radius * sin(arc.startAngle)
        let i = arc.center.x - startX
        let j = arc.center.y - startY
        
        var gcode = "\(command)"
        gcode += " X\(String(format: "%.3f", endX))"
        gcode += " Y\(String(format: "%.3f", endY))"
        gcode += " I\(String(format: "%.3f", i))"
        gcode += " J\(String(format: "%.3f", j))"
        gcode += " S\(settings.laserPower)"
        
        return gcode + "\n"
    }
    
    // MARK: - Path Optimization
    
    /// Optimize path order to minimize travel distance
    private func optimizePaths(_ paths: [SVGPath], settings: VectorSettings) -> [SVGPath] {
        guard paths.count > 1 else { return paths }
        
        if settings.minimizeTravel {
            return nearestNeighborOptimization(paths, startPoint: .zero)
        }
        
        return paths
    }
    
    /// Nearest neighbor path optimization
    private func nearestNeighborOptimization(
        _ paths: [SVGPath],
        startPoint: CGPoint
    ) -> [SVGPath] {
        var remaining = paths
        var ordered: [SVGPath] = []
        var currentPoint = startPoint
        
        while !remaining.isEmpty {
            // Find the nearest path
            var nearestIndex = 0
            var nearestDistance = Double.infinity
            
            for (index, path) in remaining.enumerated() {
                guard let pathStart = path.startPoint else { continue }
                
                let dist = distance(currentPoint, pathStart)
                if dist < nearestDistance {
                    nearestDistance = dist
                    nearestIndex = index
                }
            }
            
            // Add the nearest path
            let nearestPath = remaining.remove(at: nearestIndex)
            ordered.append(nearestPath)
            
            // Update current point
            if let endPoint = nearestPath.endPoint {
                currentPoint = endPoint
            }
        }
        
        return ordered
    }
    
    // MARK: - Progress Updates
    
    private func updateProgress(_ value: Double, operation: String) {
        Task { @MainActor in
            self.progress = value
            self.currentOperation = operation
        }
    }
}

// MARK: - Conversion Error

enum ConversionError: Error, LocalizedError {
    case noPaths
    case invalidPath
    case unsupportedElement(String)
    
    var errorDescription: String? {
        switch self {
        case .noPaths:
            return "No paths to convert"
        case .invalidPath:
            return "Invalid path data"
        case .unsupportedElement(let element):
            return "Unsupported SVG element: \(element)"
        }
    }
}

