//
//  GCodeFile.swift
//  LaserGRBL for macOS
//
//  G-code file management
//  Ported from LaserGRBL/GrblFile.cs
//

import Foundation
import SwiftUI
import Combine

/// Manages a G-code file with all its commands
class GCodeFile: ObservableObject, Identifiable {
    let id = UUID()

    @Published var commands: [GCodeCommand] = []
    @Published var fileName: String = "Untitled"
    @Published var filePath: URL?
    @Published var isModified: Bool = false
    @Published var boundingBox: BoundingBox?
    @Published var estimatedTime: TimeInterval = 0

    /// Bounding box of the G-code program
    struct BoundingBox {
        var minX: Double
        var maxX: Double
        var minY: Double
        var maxY: Double
        var minZ: Double?
        var maxZ: Double?

        var width: Double { maxX - minX }
        var height: Double { maxY - minY }
        var depth: Double? {
            guard let minZ = minZ, let maxZ = maxZ else { return nil }
            return maxZ - minZ
        }

        var centerX: Double { (minX + maxX) / 2 }
        var centerY: Double { (minY + maxY) / 2 }
    }

    // MARK: - Initialization

    init() {}

    init(filePath: URL) {
        self.filePath = filePath
        self.fileName = filePath.deletingPathExtension().lastPathComponent
    }

    // MARK: - File Loading

    /// Load G-code from a file
    func load(from url: URL) async throws {
        let startTime = Date()

        // Read file contents
        let contents = try String(contentsOf: url, encoding: .utf8)

        // Parse into commands
        let lines = contents.components(separatedBy: .newlines)
        var parsedCommands: [GCodeCommand] = []

        for (index, line) in lines.enumerated() {
            let command = GCodeCommand(rawLine: line, lineNumber: index + 1)
            if !command.isEmpty {
                parsedCommands.append(command)
            }
        }

        // Update on main thread
        await MainActor.run {
            self.commands = parsedCommands
            self.filePath = url
            self.fileName = url.deletingPathExtension().lastPathComponent
            self.isModified = false

            // Analyze the file
            self.analyze()
        }

        let elapsed = Date().timeIntervalSince(startTime)
        print("Loaded \(parsedCommands.count) commands in \(String(format: "%.2f", elapsed))s")
    }

    // MARK: - File Saving

    /// Save G-code to a file
    func save(to url: URL, includeHeader: Bool = true, includeFooter: Bool = true, cycles: Int = 1) throws {
        var output = ""

        // Add header
        if includeHeader {
            output += generateHeader()
        }

        // Add commands (repeated for multiple cycles)
        for cycle in 0..<cycles {
            for command in commands {
                output += command.rawLine + "\n"
            }

            // Add pass separator between cycles
            if cycle < cycles - 1 {
                output += "; Pass \(cycle + 1) complete\n"
            }
        }

        // Add footer
        if includeFooter {
            output += generateFooter()
        }

        // Write to file
        try output.write(to: url, atomically: true, encoding: .utf8)

        self.filePath = url
        self.fileName = url.deletingPathExtension().lastPathComponent
        self.isModified = false
    }

    /// Generate standard G-code header
    private func generateHeader() -> String {
        var header = "; Generated by LaserGRBL for macOS\n"
        header += "; Date: \(Date().formatted())\n"
        header += "; File: \(fileName)\n"
        header += "G21 ; Set units to millimeters\n"
        header += "G90 ; Absolute positioning\n"
        header += "M5 ; Laser off\n"
        header += "G0 X0 Y0 ; Move to origin\n"
        header += "\n"
        return header
    }

    /// Generate standard G-code footer
    private func generateFooter() -> String {
        var footer = "\n"
        footer += "; Program end\n"
        footer += "M5 ; Laser off\n"
        footer += "G0 X0 Y0 ; Return to origin\n"
        return footer
    }

    // MARK: - Analysis

    /// Analyze the file to calculate bounding box and time estimates
    func analyze() {
        guard !commands.isEmpty else {
            boundingBox = nil
            estimatedTime = 0
            return
        }

        var minX = Double.infinity
        var maxX = -Double.infinity
        var minY = Double.infinity
        var maxY = -Double.infinity
        var minZ: Double?
        var maxZ: Double?

        var currentX: Double = 0
        var currentY: Double = 0
        var currentZ: Double = 0
        var currentFeedRate: Double = 1000  // Default feed rate
        var totalTime: TimeInterval = 0

        for command in commands {
            // Update position
            if let x = command.x {
                currentX = x
                minX = min(minX, x)
                maxX = max(maxX, x)
            }
            if let y = command.y {
                currentY = y
                minY = min(minY, y)
                maxY = max(maxY, y)
            }
            if let z = command.z {
                currentZ = z
                if minZ == nil { minZ = z } else { minZ = min(minZ!, z) }
                if maxZ == nil { maxZ = z } else { maxZ = max(maxZ!, z) }
            }

            // Update feed rate
            if let f = command.feedRate {
                currentFeedRate = f
            }

            // Estimate time for motion commands
            if command.isMotion, let prevX = command.x, let prevY = command.y {
                let distance = sqrt(pow(currentX - prevX, 2) + pow(currentY - prevY, 2))
                if currentFeedRate > 0 {
                    totalTime += (distance / currentFeedRate) * 60  // Convert from mm/min to seconds
                }
            }
        }

        // Only create bounding box if we found valid coordinates
        if minX != .infinity && maxX != -.infinity {
            boundingBox = BoundingBox(
                minX: minX,
                maxX: maxX,
                minY: minY,
                maxY: maxY,
                minZ: minZ,
                maxZ: maxZ
            )
        } else {
            boundingBox = nil
        }

        estimatedTime = totalTime
    }

    // MARK: - Text Representation

    /// Get the full G-code as text
    var asText: String {
        commands.map { $0.rawLine }.joined(separator: "\n")
    }

    /// Update commands from edited text
    func updateFromText(_ text: String) {
        let lines = text.components(separatedBy: .newlines)
        var newCommands: [GCodeCommand] = []

        for (index, line) in lines.enumerated() {
            let command = GCodeCommand(rawLine: line, lineNumber: index + 1)
            newCommands.append(command)
        }

        self.commands = newCommands
        self.isModified = true
        self.analyze()
    }
}
